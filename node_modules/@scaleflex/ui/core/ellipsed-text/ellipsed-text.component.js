import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["children", "element", "maxLinesCount", "customMaxHeight", "noTooltip", "forceTooltip", "tooltipProps", "tooltipTitle", "textSuffix", "textWrapperProps", "ref"];
import React, { useState, useRef, useLayoutEffect, useCallback } from 'react';
import TooltipV2 from '../tooltip-v2';
import { ignoreEvent } from '../../utils/functions';
import Styled from './ellipsed-text.styles';
import { getTextSuffix } from './ellipsed-text.utils';
var POSSIBLE_FONT_GAP = 1; // there is a possibility that the font might render around ~1px in height/width for some chars so we are considering that 1px in-case.

var EllipsedText = function EllipsedText(_ref) {
  var children = _ref.children,
    _ref$element = _ref.element,
    element = _ref$element === void 0 ? 'div' : _ref$element,
    _ref$maxLinesCount = _ref.maxLinesCount,
    maxLinesCount = _ref$maxLinesCount === void 0 ? 2 : _ref$maxLinesCount,
    customMaxHeight = _ref.customMaxHeight,
    _ref$noTooltip = _ref.noTooltip,
    noTooltip = _ref$noTooltip === void 0 ? false : _ref$noTooltip,
    _ref$forceTooltip = _ref.forceTooltip,
    forceTooltip = _ref$forceTooltip === void 0 ? false : _ref$forceTooltip,
    tooltipProps = _ref.tooltipProps,
    tooltipTitle = _ref.tooltipTitle,
    textSuffix = _ref.textSuffix,
    _ref$textWrapperProps = _ref.textWrapperProps,
    textWrapperProps = _ref$textWrapperProps === void 0 ? {} : _ref$textWrapperProps,
    ref = _ref.ref,
    rest = _objectWithoutProperties(_ref, _excluded);
  var textContentRef = useRef(null);
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    shouldEllipse = _useState2[0],
    setShouldEllipse = _useState2[1];
  var applyEllipsisIfNeeded = useCallback(function (elem) {
    if (!elem || !maxLinesCount) {
      return;
    }
    var elemScrollHeight = elem.scrollHeight;
    var elemScrollWidth = elem.scrollWidth;
    var elemHeight = elem.clientHeight + POSSIBLE_FONT_GAP || elemScrollHeight;
    var elemWidth = elem.clientWidth + POSSIBLE_FONT_GAP || elemScrollWidth;
    setShouldEllipse(elemScrollHeight > elemHeight || elemScrollWidth > elemWidth);
  }, [maxLinesCount, customMaxHeight]);
  var renderTooltipTitle = function renderTooltipTitle() {
    return /*#__PURE__*/React.createElement("div", {
      onClick: ignoreEvent,
      onDoubleClick: ignoreEvent
    }, tooltipTitle || children);
  };
  useLayoutEffect(function () {
    if (textContentRef.current) {
      applyEllipsisIfNeeded(textContentRef.current);
    }
  }, [element, maxLinesCount, customMaxHeight]);
  useLayoutEffect(function () {
    var applyOnElemResize = function applyOnElemResize() {
      if (textContentRef.current) {
        applyEllipsisIfNeeded(textContentRef.current);
      }
    };
    var resizeObserver = new ResizeObserver(applyOnElemResize);
    if (textContentRef.current) {
      resizeObserver.observe(textContentRef.current);
    }
    return function () {
      resizeObserver.disconnect();
    };
  }, []);
  var renderEllipsedText = function renderEllipsedText() {
    return /*#__PURE__*/React.createElement(Styled.EllipsedTextWrapper, _extends({
      $maxLinesCount: maxLinesCount,
      ref: textContentRef
    }, textWrapperProps, rest), shouldEllipse && !noTooltip || forceTooltip ? /*#__PURE__*/React.createElement(TooltipV2, _extends({
      position: "top",
      size: "md",
      ref: ref,
      arrow: true
    }, tooltipProps, {
      title: renderTooltipTitle()
    }), /*#__PURE__*/React.createElement(Styled.TooltipContent, {
      as: element,
      $customMaxHeight: customMaxHeight
    }, children)) : children);
  };
  return textSuffix && shouldEllipse ? /*#__PURE__*/React.createElement(Styled.EllipsedTextContainer, null, renderEllipsedText(), /*#__PURE__*/React.createElement(Styled.SuffixTextWrapper, null, getTextSuffix(textSuffix))) : renderEllipsedText();
};
export default EllipsedText;